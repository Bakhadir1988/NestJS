# Сериализация в NestJS: Контроль над исходящими данными

## 1. Краткое описание темы

**Сериализация** — это процесс преобразования объекта (например, экземпляра класса из вашего сервиса) в определённый формат (например, JSON) для его последующей передачи. В контексте NestJS, это мощный механизм, который позволяет **контролировать, какие именно данные вашего объекта будут отправлены клиенту**.

Главное применение — **безопасность**. Мы используем сериализацию, чтобы исключить из ответа API конфиденциальную информацию, такую как пароли пользователей, внутренние флаги или любые другие данные, которые не должны быть видны на frontend'е.

## 2. Ключевые концепции

NestJS реализует сериализацию с помощью двух ключевых элементов: `ClassSerializerInterceptor` и библиотеки `class-transformer`.

| Концепция                   | Описание                                                                                                                                      |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `ClassSerializerInterceptor`| Встроенный Interceptor, который автоматически перехватывает исходящие ответы (объекты или массивы объектов) и преобразует их.                 |
| `class-transformer`         | Библиотека, которую Interceptor использует "под капотом". Она предоставляет декораторы для управления процессом трансформации.                 |
| **Декораторы**              |                                                                                                                                               |
| `@Exclude()`                | **Исключает** свойство из финального JSON. Самый частый декоратор для скрытия полей.                                                          |
| `@Expose()`                 | **Включает** свойство в финальный JSON. Используется в связке с `@Exclude()` на уровне класса, чтобы создать стратегию "белого списка".       |
| `@Transform()`              | Позволяет **преобразовать** значение свойства перед отправкой. Например, превратить `string` в `number` или объединить несколько полей в одно. |

**Важно:** Сериализация работает только с **экземплярами классов**, а не с "сырыми" объектами JavaScript (`{}`). Ваш сервис должен возвращать `new UserEntity(...)`, а не просто `{ id: 1, ... }`.

## 3. Пример кода

Представим, что наш `UserService` возвращает объект пользователя, который мы получили из базы данных.

**1. Создадим `UserEntity` (сущность/DTO для ответа):**
Этот класс описывает, как должен выглядеть пользователь в ответе API.

```typescript
// src/users/entities/user.entity.ts
import { Exclude } from 'class-transformer';
import { User } from '@prisma/client';

export class UserEntity implements User {
  id: number;
  email: string;
  name: string | null;

  @Exclude() // <-- Вот магия!
  password_hash: string; // Предположим, поле в БД называется так

  // Конструктор для удобства преобразования
  constructor(partial: Partial<UserEntity>) {
    Object.assign(this, partial);
  }
}
```

**2. Применим `ClassSerializerInterceptor` в контроллере:**

```typescript
// src/users/users.controller.ts
import { Controller, Get, Param, UseInterceptors, ClassSerializerInterceptor } from '@nestjs/common';
import { UsersService } from './users.service';
import { UserEntity } from './entities/user.entity';

@Controller('users')
// Применяем Interceptor ко всем маршрутам этого контроллера
@UseInterceptors(ClassSerializerInterceptor)
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<UserEntity> {
    // Сервис возвращает экземпляр UserEntity
    const user = await this.usersService.findOne(+id);
    return new UserEntity(user);
  }
}
```

**Результат:**
Когда клиент сделает запрос `GET /users/1`, `ClassSerializerInterceptor` перехватит объект `UserEntity`, увидит декоратор `@Exclude()` на поле `password_hash` и удалит его перед отправкой JSON.

**Клиент получит:**
```json
{
  "id": 1,
  "email": "user@example.com",
  "name": "John Doe"
}
```
...вместо:
```json
{
  "id": 1,
  "email": "user@example.com",
  "name": "John Doe",
  "password_hash": "a_very_long_and_secret_hash"
}
```

## 4. Частые ошибки

1.  **Забыть применить `ClassSerializerInterceptor`**. Декораторы `@Exclude`/`@Expose` не будут работать без этого интерцептора. Его можно применять глобально в `main.ts`, на уровне контроллера или для конкретного эндпоинта.
2.  **Возвращать из сервиса "сырой" объект, а не экземпляр класса**. `class-transformer` работает только с классами. Если ваш сервис вернёт `{ id: 1, ... }`, интерцептор ничего не сделает.
3.  **Пытаться использовать декораторы на интерфейсах TypeScript**. Декораторы — это функциональность классов. Интерфейсы существуют только на этапе компиляции и не могут быть использованы для сериализации.

## 5. Best Practices

-   **Применяйте `ClassSerializerInterceptor` глобально** в `main.ts`, чтобы обеспечить единое поведение для всего приложения.
    ```typescript
    // main.ts
    app.useGlobalInterceptors(new ClassSerializerInterceptor(app.get(Reflector)));
    ```
-   **Создавайте отдельные `Entity` или Response DTO** для ответов API. Не возвращайте напрямую сущности Prisma/TypeORM. Это разделяет вашу базу данных и публичный контракт API, делая систему более гибкой и безопасной.
-   **Используйте `@Exclude()` по умолчанию** для всех полей в базовом классе сущности, а в дочерних DTO **выборочно открывайте поля с помощью `@Expose()`**. Это стратегия "белого списка", которая считается более безопасной.

## 6. Краткий вывод

Сериализация — это не просто "фича", а **обязательный инструмент** для создания безопасных и профессиональных API. Она дает вам полный контроль над тем, какие данные видит клиент, предотвращая утечки конфиденциальной информации и позволяя формировать чистые и предсказуемые ответы.

---

## 7. Практическое задание

Теперь давайте применим эти знания на практике и защитим данные нашего пользователя.

1.  **Обновите схему Prisma:** В файле `prisma/schema.prisma` раскомментируйте поле `password` у модели `User`.
2.  **Создайте и примените миграцию:** Выполните в терминале `npx prisma migrate dev --name add_user_password`, чтобы добавить поле в базу данных.
3.  **Создайте `UsersModule`:** Используйте Nest CLI, чтобы сгенерировать полный модуль для пользователей: `nest g resource users`. На вопрос "What transport layer do you use?" выберите `REST API`.
4.  **Реализуйте сервис:** В `src/users/users.service.ts` реализуйте метод `findOne(id: number)`, который будет находить и возвращать пользователя из БД с помощью `PrismaService`.
5.  **Реализуйте контроллер:** В `src/users/users.controller.ts` убедитесь, что эндпоинт `GET /users/:id` вызывает ваш сервис и возвращает результат.
6.  **Создайте `UserEntity`:** В `src/users/entities/user.entity.ts` создайте класс `UserEntity`, который будет реализовывать модель `User` из Prisma, и пометьте поле `password` декоратором `@Exclude()`. Не забудьте добавить конструктор, как в примере выше.
7.  **Примените сериализацию:**
    -   В `main.ts` зарегистрируйте `ClassSerializerInterceptor` глобально.
    -   Измените `users.service.ts` и `users.controller.ts` так, чтобы они возвращали экземпляр `UserEntity`.
8.  **Протестируйте:** Создайте пользователя вручную в базе данных или реализуйте метод `create` в контроллере. Затем сделайте запрос на `GET /users/:id` и убедитесь, что поле `password` отсутствует в ответе.
