# Пайпы (Pipes) в NestJS

Пайпы (Pipes) — это один из фундаментальных строительных блоков NestJS. Их основная задача — обрабатывать **входящие данные**, которые поступают в ваши методы контроллера.

**Место в цикле запроса:** Пайпы выполняются после гардов, но перед самим обработчиком роута.
`Request -> Middleware -> Guard -> **Pipe** -> Route Handler`

---

## 1. Две главные задачи Пайпов

У пайпов есть две основные, часто пересекающиеся функции:

### 1.1. Преобразование (Transformation)

Пайп может взять входящие данные и преобразовать их в желаемый формат.
- **Пример:** Входящий параметр из URL всегда является строкой. Если нам нужен `id` в виде числа, мы используем `ParseIntPipe`, который превратит строку `"123"` в число `123`.

**Встроенные пайпы для преобразования:**
-   `ParseIntPipe`: Преобразует строку в целое число.
-   `ParseFloatPipe`: Преобразует строку в число с плавающей точкой.
-   `ParseBoolPipe`: Преобразует строку (`"true"`, `"false"`) в булево значение.
-   `ParseArrayPipe`: Проверяет, что значение является массивом, и может преобразовывать его элементы.
-   `ParseUUIDPipe`: Проверяет, что строка является UUID.

### 1.2. Валидация (Validation)

Пайп может проверить, соответствуют ли входящие данные определенным критериям. Если данные некорректны, пайп должен выбросить исключение (обычно `BadRequestException`).
- **Пример:** Наш любимый `ValidationPipe`! Он автоматически использует декораторы из библиотеки `class-validator` (например, `@IsString()`, `@IsEmail()`) в наших DTO-классах, чтобы проверить тело (`@Body`), параметры (`@Query`) или путь (`@Param`) запроса.

---

## 2. Как использовать Пайпы

Пайпы можно применять на разных уровнях:

**1. На уровне параметра:**
Это самый частый способ использования пайпов для преобразования.
```typescript
@Get(':id')
findOne(@Param('id', ParseIntPipe) id: number) {
  // к этому моменту id - это уже гарантированно число
  return this.usersService.findOne(id);
}
```

**2. На уровне метода контроллера:**
Используется декоратор `@UsePipes()`.
```typescript
@Post()
@UsePipes(new ValidationPipe())
create(@Body() createUserDto: CreateUserDto) {
  // тело запроса будет провалидировано перед вызовом этого метода
  return this.usersService.create(createUserDto);
}
```

**3. Глобально на уровне всего приложения:**
Это самый удобный способ применить один пайп (обычно `ValidationPipe`) ко всем эндпоинтам сразу. Мы делаем это в `main.ts`.
```typescript
// src/main.ts
app.useGlobalPipes(new ValidationPipe({
  whitelist: true, // Автоматически удаляет свойства, которых нет в DTO
}));
```

---

## 3. Создание кастомных Пайпов

Вы всегда можете создать свой собственный пайп. Для этого нужно создать класс, который реализует интерфейс `PipeTransform`.
```typescript
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class MyCustomPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    // ... ваша логика преобразования или валидации ...
    const newValue = value.toString().toUpperCase();
    return newValue;
  }
}
```
Ранее мы уже рассматривали создание кастомных пайпов в разделе `02_Data_Validation`.

---

## 4. Вывод

Пайпы — это мощный инструмент для обеспечения чистоты и корректности данных, поступающих в ваши контроллеры. Используя комбинацию встроенных и кастомных пайпов, вы можете быть уверены, что ваши сервисы и бизнес-логика всегда получают данные в ожидаемом формате и виде.
