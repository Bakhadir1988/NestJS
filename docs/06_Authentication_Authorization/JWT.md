# Аутентификация с помощью JWT (Простыми словами)

Представьте, что наше приложение — это закрытый клуб. Чтобы в него попасть, простого `X-API-KEY` недостаточно, ведь он один для всех. Нам нужен способ выдавать каждому пользователю персональный пропуск. JWT — это и есть такой электронный пропуск.

**Аналогия:**
1.  **Вход (Логин):** Вы подходите к охраннику на входе в клуб (`/auth/login`) и показываете свой паспорт (логин и пароль).
2.  **Выдача пропуска (JWT):** Охранник проверяет ваш паспорт. Если все в порядке, он надевает вам на руку браслет (выдает JWT-токен). На браслете может быть написано ваше имя и возраст (`payload`).
3.  **Доступ внутрь:** Теперь вы можете ходить по всему клубу. У входа в VIP-зону (`/boards`) стоит другой охранник. Вы просто показываете ему браслет, и он вас пропускает. Вам больше не нужно каждый раз доставать паспорт.
4.  **Безопасность:** Браслет сделан так, что его невозможно подделать или незаметно снять и передать другому (это обеспечивает **цифровая подпись** токена).

---

## 1. Из чего состоит JWT?

Сам токен — это просто длинная строка, разделенная точками на три части: `Header.Payload.Signature`.

1.  **Header (Заголовок):** Служебная информация. "Тип: JWT, Алгоритм шифрования: HS256".
2.  **Payload (Полезная нагрузка):** Данные, которые мы хотим "зашить" в пропуск. Самое главное для нас — это ID пользователя. Стандартное имя для этого поля — `sub` (subject).
3.  **Signature (Подпись):** Самая важная часть. Это "печать", которая гарантирует, что токен не был изменен. Она создается с помощью хедера, полезной нагрузки и **секретного ключа**, который хранится только на нашем сервере.

---

## 2. Как мы будем это использовать в NestJS?

Процесс состоит из нескольких шагов, которые мы обернем в новый `AuthModule`.

1.  **Установка библиотек:** Нам понадобятся `@nestjs/jwt` для работы с токенами и `bcrypt` для безопасного сравнения паролей.
2.  **Создание `AuthModule`:** Новый модуль, который будет отвечать за всю логику аутентификации.
3.  **Настройка `JwtModule`:** Мы зарегистрируем его в нашем `AuthModule` и передадим ему наш секретный ключ.
4.  **Создание `AuthService`:** В нем будет логика:
    -   `validateUser()`: Находит пользователя и проверяет, совпадает ли пароль.
    -   `login()`: Если пользователь валиден, генерирует и возвращает ему JWT-токен.
5.  **Создание `AuthController`:** Контроллер с одним эндпоинтом `/auth/login`.
6.  **Создание `JwtStrategy`:** Это специальный "помощник" для нашего гарда. Его задача — прочитать токен из заголовка запроса, проверить его подпись и вернуть данные пользователя (payload).
7.  **Создание `JwtAuthGuard`:** Наш новый гард, который будет использовать `JwtStrategy` для защиты эндпоинтов.

---

## 3. Пример кода (Ключевые фрагменты)

**Настройка `AuthModule`:**
```typescript
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';

@Module({
  imports: [
    JwtModule.register({
      secret: 'YOUR_SUPER_SECRET_KEY', // Временно, потом перенесем в .env
      signOptions: { expiresIn: '60m' }, // Токен будет жить 60 минут
    }),
  ],
  // ... providers, controllers
})
export class AuthModule {}
```

**Логин в `AuthService`:**
```typescript
// src/auth/auth.service.ts
@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async login(user: any) {
    const payload = { sub: user.id, name: user.name };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}
```

---

## 4. Краткий вывод

JWT — это безопасный и стандартный способ аутентификации пользователей в API. Мы выдаем пользователю временный "пропуск" (токен) после успешного логина, а затем проверяем этот пропуск на защищенных эндпоинтах. Это избавляет от необходимости передавать логин и пароль в каждом запросе.

---

## 5. Практическое задание

Наша цель — создать полноценный процесс логина.

1.  **Установите зависимости:**
    ```bash
    npm install @nestjs/jwt passport passport-jwt bcrypt
    npm install --save-dev @types/passport-jwt @types/bcrypt
    ```

2.  **Создайте `AuthModule`:**
    -   Используйте CLI: `nest g mo auth`.
    -   Создайте `AuthController` (`nest g co auth`), `AuthService` (`nest g s auth`).

3.  **Настройте `AuthModule` (`src/auth/auth.module.ts`):**
    -   Импортируйте `UsersModule`, чтобы можно было использовать `UsersService`.
    -   Настройте `JwtModule.register()`, как в примере выше. В `secret` пока можно написать любую строку.
    -   Добавьте `AuthService` и `UsersService` в `providers`.

4.  **Реализуйте логику в `AuthService`:**
    -   Создайте метод `validateUser(email: string, pass: string)`. Он должен:
        -   Найти пользователя по `email` через `UsersService`.
        -   Если пользователь найден, сравнить хеш пароля из БД с паролем `pass` с помощью `bcrypt.compare()`.
        -   Вернуть `user` если все совпадает, или `null` если нет.
    -   Создайте метод `login(user: User)` который принимает объект пользователя и генерирует токен (код есть в примере выше).

5.  **Создайте эндпоинт в `AuthController`:**
    -   Создайте метод для `POST /auth/login`.
    -   Он должен вызывать `authService.validateUser()`, а затем `authService.login()`.

6.  **Создайте `JwtStrategy` и `JwtAuthGuard`:**
    -   Создайте папку `src/auth/strategies` и в ней файл `jwt.strategy.ts`. В нем будет класс, который расширяет `PassportStrategy(Strategy)`. Это самый сложный шаг, я помогу, если будут трудности.
    -   Создайте `JwtAuthGuard`. Он будет очень простым: `export class JwtAuthGuard extends AuthGuard('jwt') {}`.

7.  **Проверьте:**
    -   В Postman отправьте `POST` запрос на `http://localhost:3000/api/auth/login` с `email` и `password` существующего пользователя. Вы должны получить `access_token`.
    -   Попробуйте получить доступ к `GET http://localhost:3000/api/users`, добавив заголовок `Authorization` со значением `Bearer ВАШ_ПОЛУЧЕННЫЙ_ТОКЕН`.
